<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学习实现webpack打包]]></title>
    <url>%2F2019%2F09%2F07%2F%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0webpack%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[学习实现一个简陋的打包流程 随着前端模块化的趋势，知道 webpack 如何打包是很有必要的简单打包需要 3 个步骤： 传入入口文件的路径，返回一个包含文件名，依赖和代码的对象。 通过 babel 的 parse 解析生成文件抽象语法树 通过 traverse 遍历 AST, 获取依赖 通过 transformFromAst 方法，依据你指定的规则生成对应的代码(https://babeljs.io/docs/en/babel-preset-env) 分析文件依赖，生成依赖图谱，包含文件路径和对应的依赖以及代码 输出浏览器可执行的代码到指定的输出目录下 preparation12345const fs = require("fs");const path = require("path");const parser = require("@babel/parser");const traverse = require("@babel/traverse").default;const &#123; transformFromAst &#125; = require("@babel/core"); step one123456789101112131415161718192021222324252627282930const getModule = entryFile =&gt; &#123; //读取到文件内容 const content = fs.readFileSync(entryFile, "utf-8"); //解析文件内容成抽象语法树 const ast = parser.parse(content, &#123; sourceType: "module" //用于识别es module &#125;); const dependencies = &#123;&#125;; //遍历ast， 找出import并提取依赖保存到dependencies对象中。 traverse(ast, &#123; ImportDeclaration(&#123; node &#125;) &#123; const fileName = node.source.value, dirname = path.dirname(filename), //获取文件的目录路径 filePath = path.join(dirname, fileName); //拼接目录路径与文件名，合成完成路径 dependencies[fileName] = filePath; &#125; &#125;); //按照定义的规则，如果没有就是默认规则，生成代码块 const &#123; code &#125; = transformFromAst(&#123; presets: ["@babel/preset-env"] &#125;); //返回文件解析后对应的内容，包含文件名，依赖对象，代码 return &#123; filename, dependencies, code &#125;;&#125;; step two1234567891011121314151617181920212223242526const genDepGraph = entryFile =&gt; &#123; //首先拿到入口文件的模块信息 const module = getModule(entryFile); const modules = []; //将入口文件的模块信息加入到模块数组中 modules.push(module); //通过入口模块，去检索并将所有依赖模块信息存入 for (let i = 0; i &lt; modules.length; i++) &#123; const item = modules[i]; const &#123; dependencies &#125; = item; if (dependencies) &#123; for (let j in dependencies) &#123; modules.push(getModule(dependencies[j])); &#125; &#125; &#125; //生成依赖图谱 const graph = modules.reduce((acc, item) =&gt; &#123; const &#123; filename, dependencies, code &#125; = item; acc[filename] = &#123; dependencies, code &#125;; &#125;, &#123;&#125;); return graph;&#125;; step three123456789101112131415161718192021222324252627const genCode = entryFile =&gt; &#123; const graph = JSON.stringify(genDepGraph(entryFile)); //这里像webpack那样植入了一段js 代码用来告诉浏览器应该怎么去加载生成的代码。 //稍微的分析 /** 1. require做了什么？ (function(require, exports, code)&#123;&#125;(localRequire, exports, graph[module].code))() 这个自执行函数会去递归的执行生成的代码，并以对象的形式返回。 */ const bundle = ` (function(graph)&#123; function require(module)&#123; function localRequire(relativePath)&#123; return require(graph[module].dependencies[relativePath]) &#125; var exports = &#123;&#125;; (function(require, exports, code)&#123; eval(code) &#125;)(localRequire, exports, graph[module].code) return exports; &#125; require('$&#123;entryFile&#125;') &#125;)($&#123;graph&#125;) `; fs.writeFileSync(path.join(__dirname, "./dist/main.js"), bundle, "utf-8");&#125;;genCode("./src/index.js"); 按照 webpack 官方文档学习制作简单的 loader 和 plugin 首先是需要安装 webpack， 创建一个 loader 文件夹，创建一个你自己 loader 123456789101112131415npm install webpack -Dmkdir loadertouch replaceLoader.js//loader其实说白了就是接收配置参数，做转换并将转换后的输出//每个loader的功能单一，只关注一方面的内容const loaderUtils = require("loader-utils");module.exports = function(src) &#123; console.log(typeof src); const ops = loaderUtils.getOptions(this); const res = src.replace(/kkb/gi, ops.name); return res;&#125;; 配置 webpack config 文件 webpack.config.js 123456789101112131415161718192021module.exports = &#123; mode: "development", resolveLoader: &#123; modules: ["node_modules", "./loader"] &#125;, module: &#123; rules: [ &#123; test: /\.js$/, use: [ &#123; loader: "replaceLoader", options: &#123; name: "开课吧" &#125; &#125; ] &#125; ] &#125;&#125;; 最后就是执行 webpack，检查输出的内容。https://webpack.docschina.org/contribute/writing-a-loader/ 1npx webpack 关于 plugin， 创建 plugins 目录，创建 CopyrightWebpackPlugin.js 12345678910111213141516171819202122class CopyrightWebpackPlugin &#123; constructor(options) &#123;&#125; apply(compiler) &#123; compiler.hooks.emit.tapAsync( "CopyrightWebpackPlugin", (compilation, cb) =&gt; &#123; compilation.assets["copyright.txt"] = &#123; source: function() &#123; return "hello copy"; &#125;, size: function() &#123; return 20; &#125; &#125;; cb(); &#125; ); &#125;&#125;module.exports = CopyrightWebpackPlugin; 配置 webpack123456789101112131415161718192021222324252627282930313233343536// @ts-nocheckconst path = require("path");const CopyrightWebpackPlugin = require("./plugins/CopyrightWebpackPlugin");module.exports = &#123; mode: "development", resolveLoader: &#123; modules: ["node_modules", "./loader"] &#125;, module: &#123; rules: [ &#123; test: /\.js$/, use: [ &#123; loader: "replaceLoaderAsync", options: &#123; name: "babala" &#125; &#125;, &#123; loader: "replaceLoader", options: &#123; name: "开课吧" &#125; &#125; ] &#125; ] &#125;, plugins: [ new CopyrightWebpackPlugin(&#123; name: "kkb" &#125;) ]&#125;; 执行 webpack,检查生成 dist 目录下的文件https://webpack.docschina.org/contribute/writing-a-plugin/ 1npx webpack]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在taro项目中引入第三方的库]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%A6%82%E4%BD%95%E5%9C%A8taro%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BC%95%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在使用 Taro 开发小程序，如何正确加载第三方字体库遇到的问题按照官方文档https://taro-ui.aotu.io/#/docs/iconicon 并没有正确的加载并显示出来，通过小程序的调试器，虽然可以看到添加的 css，但实际上并不起作用。 在谷歌上搜索了相关的关键字，https://github.com/NervJS/taro-ui/issues/202发现有相似的解决方法 里面提到一个方法将 font awesome 转成 base64 格式, 然后将打包的文件解压到存放资源文件的目录，就成功解决了实际上如果去看 taro aticon 的语法，也是同样的原理，但是不清楚通过 url 引用的方式为什么不起作用 工具网址：https://transfonter.org/使用的手势：https://blog.csdn.net/qq_28988969/article/details/76633921 step1: 去 font-awesome 官网下载字体包step2: 去https://transfonter.org/转成base64格式的引用,下载包到本地step3: copy stylesheet.css 的内容到具体的字体的样式表中，然后就可以定义具体的 content]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>taro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混入带来的一些问题]]></title>
    <url>%2F2019%2F07%2F29%2Fmixins-harmful%2F</url>
    <content type="text"><![CDATA[混入带来的一些问题1如何在组件之间共享代码？这是在学习react时，人们最先问的问题，答案一般都是通过组件组合的方式重用代码。你可以定义一个组件，并且使用在其他组件。 为什么混入具有破坏性在 facebook, react 的使用从只有一些组件到成千上万的组件，这使得我们可以有机会思考下人们是如何使用 react。多亏了声明式的返回和自上而下的数据流，许多团队可以在发布新的功能时处理一堆的问题。 然而不可避免的是随着功能点和代码量的增多，逐渐会有一部分代码变得晦涩难懂。特别是别使用在多个项目中的组件，往往使工程师对修改感到恐惧。这些组件很容易被破坏，对新开发者不友好，有时甚至对于模块的创建者也会感到困惑，诸多这些都由混入引起。 但这并不意味着混入本身是无益的，人们已经成功的在不同语言和模型中使用他们。然而作者任务混入是没有必要且有问题的。 混入会带来隐式的依赖问题有些时候一个组件依赖于定义在 mixin 中的某个方法，比方说 getClassName(),有时可能会是其他的方法，列如 renderHeader().js 是一种动态语言，因此很困难去增强或是记录这些依赖。 混入破环了普遍性，并且需做安全性的思考，当你重新命名一个状态的键或者方法，你需要去全局搜索下你修改的键出现的频率。你可能会写了一个有状态的组件，而你的同事可能加入了一个混入去读取这个状态。然后过了几个月，你可能想要提升这个状态到父组件，这样可以被一个滑动共享，你会记得去更新这个状态在 mixin 中去读取 prop，要是其他的组件也使用到了这个混入？ 这些隐式的依赖使得新成员去贡献代码变得很困难。一个组件的 render 方法可能会引用到一些在类中没有被定义过的方法，这些方法可以被安全的删除？也许他被定义在 mixin 中的一个，但具体是哪一个？需要去查看 mixin 的清单，打开这些文件中的每一个，去寻找这个方法。更糟糕的是，mixin 也可以指定 mixin，这样就会有深层次嵌套查找。 混入没有层级关系，它们是扁平的并且运行在同一个命名空间。 混入引起的名字问题如果在两个混入函数中有同名的方法，无法同时使用。 在遇到冲突时，你可以重命名其中的一个，然而有意思的是由于重命名的混入方法可能已经被其他组件或 mixin 所引用，那么你就得相应得去处理由这次修改所引起得副作用 假设你有个冲突来自和第三方得库，你不得不使用更复杂得名字避免命名冲突 一旦 mixins 写好，随着时间推移，移除和修改会变得越来越困难，重构得风险也越来越大。 混入还会引起雪球复杂度一个组件需要状态去跟踪鼠标悬浮。为保持逻辑得复用，你可能抽取 handleMouseEnter(), handleMouseLeave(), 和 isHovering()到 hovermixin 中。下一步，有些人需要实现 tooltip，他们想复用在 hovermixin 中的逻辑，因此他们创建了 TooltipMixin,使用 hovermixin 提供的 isHovering 的函数，来显示是否显示或隐藏。 几个月之后，有人想让 tooltip 可以有方向上的配置，为了避免代码的重复，增加了新的方法 getTooltipOptions()到 TooltipMixin，如果还需要配置 hover delay 的时间，解决这个问题需要在增加 getHoverOption 如果需要支持在单一组件中展示多个 tooltips？你无法定义两个一样的 mixin 在一个组件，如果 tooltip 需要根据 guided tour 自动的展示？ 每一个新的需求都会使 mixin 更难于理解，使用同样 mixin 函数的组件随着时间的推移耦合度逐渐增加任何一个新的功能都会相应的增加到使用这个 mixin 的组件中，封装的边界会变得越来越模糊，因为很难去改变和移除这些存在的 mixin，所以只有不断对 mixin 做抽象，直到没有人理解这到底是做什么的 这些问题可以通过声明式的返回，自上而下的数据流和封装过的组件来解决。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>mixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面渲染需要了解的东西]]></title>
    <url>%2F2019%2F07%2F22%2Fwebpage-rendering%2F</url>
    <content type="text"><![CDATA[页面渲染需要了解的东西参考：https://aerotwist.com/blog/pixels-are-expensive/https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/ 60FPS，是前台页面显示所追求的效果。折算下来就是一帧需要 16.667ms 浏览器在每一帧所需要做的事情 js =&gt; style =&gt; layout =&gt; paint =&gt; composite css 中常见的属性分类参考：https://csstriggers.com/https://docs.google.com/spreadsheets/d/1Hvi0nu2wG3oQ51XRHtMv-A_ZlidnwUYwgQsPQUg1R2s/pub?single=true&amp;gid=0&amp;output=html layout:width, height, padding, margin, display, border-width, bordertop, position, font-size, float, background-color, border-colortext-aligin, overflow-y, font-weight, overflow, left, font-familiymargin-bottom, padding-bottom, line-height, vertical-align, right,clear, etc paint:color, border-style, visibility, background, text-decoration, background-image, background-position, background-repeat, etc composite:opacity, cursor, z-index]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2F2019%2F07%2F22%2FBFC%2F</url>
    <content type="text"><![CDATA[什么是 BFCBFC =&gt; block formatting context, 中文直译块格式化上下文 视觉格式化模型视觉格式化模型定义了 box 的生成，盒包含块盒，行内盒，匿名盒，以及实验盒，盒的类型由 display 属性决定 块盒当元素 display 属性为 block, list-item 或 table视觉上上呈现为块状，垂直排列每个块级元素至少生成一个块级盒，称为主要块级盒块级盒参与 行内盒当元素 display 属性是 inline，inline-block 或 inline-table视觉上将内容与行内级元素排列为多行行内级元素生成行内级盒，参与行内格式化上下文不参与行内格式化上下文的行内级盒称为原子行内级盒，display 值为 inline-block,inline-table 匿名盒分为匿名块盒盒匿名行内盒，因为没有具体的名字，也无法用选择器来选择他们，所以他们的所有属性都为 inherit 或初始默认值 三个定位方案 常规流盒是一个接着一个排列在块级上下文，是垂直排列在行内上下文，水平排列当 poisition 为 static 或 relative，并且 float 为 none 时触发常规流对于静态定位，盒的位置是常规流布局里的位置对于相对定位，盒的位置由 top right bottom left.即使偏移，仍然保持原有位置，其他常规流不能占用 浮动它位于开头或末尾导致常规流围绕在它周边，除非设置了 clear 属性 绝对定位绝对定位，当盒从常规流中移除，不影响常规流布局定位相对于它的包含块，top right bottom leftposition 是 absolute 或 fixed对于 position: absolute,元素定位将相对于最近的一个 relative, fixed, absolute 的父元素，如果没有就是 body BFC 的创建方法根元素() 浮动元素（元素的 float 不是 none）绝对定位元素（元素的 position 为 absolute 或 fixed）行内块元素（元素的 display 为 inline-block）表格单元格（元素的 display 为 table-cell，HTML 表格单元格默认为该值）表格标题（元素的 display 为 table-caption，HTML 表格标题默认为该值）匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）overflow 值不为 visible 的块元素display 值为 flow-root 的元素contain 值为 layout、content 或 strict 的元素弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）网格元素（display 为 grid 或 inline-grid 元素的直接子元素）多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）column-span 为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。BFC 的效果 内部的盒会在垂直方向上一个接着一个排列 处于同一个 BFC 中的元素相互影响 每一个 margin box 的左边，与容器块 border box 的左边接触。即使存在浮动也是如此； BFC 就是页面上的一个隔离的独立容器，容器内的子元素不会影响到外面的元素，同时也不会收到外面元素的影响 计算 BFC 高度的时候，考虑 BFC 所包含的所有元素，连浮动元素也参与计算 浮动盒区域不叠加到 BFC 上 总结在实际中，利用 BFC 可以闭合浮动，防止浮动元素重叠。同时，由于 BFC 的隔离作用，可以利用 BFC 包含一个元素，防止这个元素与 BFC 外的元素发生 margin collapse]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口]]></title>
    <url>%2F2019%2F07%2F21%2Falgorithm-02%2F</url>
    <content type="text"><![CDATA[滑动窗口模式用在给定数组或链表的特定窗口大小上执行所需的操作一般的解法是从第一个元素开始滑动窗口，维持一前一后两个游标，根据所求解的问题调整窗口长度 leetcode 53描述： Given an integer array nums,find the contiguous subarray (containing at least one number ， which has the largest sum and return its sum.Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxSubArray = function(nums) &#123; let sum = 0, max = nums[0], size = nums.length; for (let i = 0; i &lt; size; i++) &#123; sum += nums[i]; max = max &gt; sum ? max : (max = sum); if (sum &lt; 0) &#123; sum = 0; &#125; &#125; return max;&#125;; leetcode 3描述：Given a string, find the length of the longest substring without repeating characters.Example 1:Input: “abcabcbb”Output: 3Explanation: The answer is “abc”, with the length of 3. 1234567891011121314151617181920212223242526/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; const size = s.length, f1 = s.charAt(0), tmpArr = [f1]; if (size === 0) return 0; if (size === 1) return 1; let max = 0; for (let i = 1; i &lt; size; i++) &#123; let c = s.charAt(i), existed_pos = tmpArr.indexOf(c); if (existed_pos &gt; -1) &#123; if (i === size - 1) break; max = max &gt; tmpArr.length ? max : (max = tmpArr.length); i = i - (tmpArr.length - existed_pos - 1); c = s.charAt(i); tmpArr.length = 0; &#125; tmpArr.push(c); &#125; max = max &gt; tmpArr.length ? max : (max = tmpArr.length); return max;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>滑动窗口模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BF算法学习]]></title>
    <url>%2F2019%2F07%2F21%2Falgorithm-01%2F</url>
    <content type="text"><![CDATA[BF 算法 Brute-Force 算法， 是一种简单朴素的模式匹配算法，常用于在一个主串内查找一个子串的问题依据解题思路假设主串 S 和子串 T， 子串长度 M， 主串长度 N， 0 &lt; M &lt;= N 先比较 S[1]和 T[1], 如果相同，继续比较 S[2]和 T[2], 直到 M 如果不同，指针移动至 S[2],再重复第一次的比较 1234567891011121314151617181920212223function findSubArrayStartIndex(total, part) &#123; var size = total.length, matched_size = part.length; for (let i = 0; i &lt; size; i++) &#123; const tmp1 = total.slice(i, matched_size + i); if (isMatched(tmp1, part)) return i; &#125; return -1;&#125;function isMatched(part1, part2) &#123; if (part1.length !== part2.length) return false; const size = part1.length, flg = false; for (let i = 0; i &lt; size; i++) &#123; if (part1[i] !== part2[i]) &#123; flg = false; break; &#125; if (i === size - 1) flg = true; &#125; return flg;&#125; 在匹配失败时，主串的回溯的操作会影响效率，这种简单丢弃匹配信息的算法是其低效的原因。 参考自https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247485906&amp;idx=1&amp;sn=f00a07cbca83d345cbacc327e335de2d&amp;chksm=fa0e6653cd79ef45a9566cd8ea947d122cfde8e1c9459332e4d7d04f06644fc7a6e81da7ee10&amp;scene=0&amp;xtrack=1&amp;key=034516426b2066d034c7c1b29870ede14e8a92b4535b464417555eba97ffe9cb08b0adf1bed2cd2cacdd73d13e652ee5856b3c801071439294a57ca6c1dabaa8bf97d0b015a0f622d6a99a12f2aa990d&amp;ascene=1&amp;uin=MjgyMTkzMDA4NA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=2s0OQl6S2cyRyPHwnDgNJKM3678%2F2wSuNoGHFaGq9qSejQtHFU3wZMAHfkIJm5Wr]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模式匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS每日练习]]></title>
    <url>%2F2019%2F07%2F16%2Fjs-lianxi%2F</url>
    <content type="text"><![CDATA[浏览器控制台上会打印什么123456var a = 10;function foo() &#123; console.log(a); var a = 20;&#125;foo(); 答案是：undefined原因：在执行函数前，js 引擎会先扫描代码块，变量声明提升到代码的最前面.这样的话，实际打印的 a 就是 undefined. 12345function foo() &#123; var a; console.log(a); a = 20;&#125; 如果我们使用 let 或 const 代替 var，输出是否相同12345function foo() &#123; console.log(a); let a = 20;&#125;foo(); 答案是会抛出异常： Uncaught ReferenceError: Cannot access ‘a’ before initialization这是因为 let 和 const 可以让变量在其作用域上受限于它使用的代码块，语句或表达式。这时的 a 会放在 TDZ 区域。只有执行到声明才能访问到它。 “newArray”中有哪些元素？123456var array = [];for (var i = 0; i &lt; 3; i++) &#123; array.push(() =&gt; i);&#125;var newArray = array.map(e =&gt; e());console.log(newArray); 答案是[3,3,3], 首先数组中保存了 3 个函数对象，在做 map 时，分别执行每一个函数，函数执行后返回 i，i 此时是全局变量 3，所以在数组中一共是 3 个 3. 如果我们在浏览器控制台中运行 foo 函数，是否会导致堆栈溢出错误123function foo() &#123; setTimeout(foo, 0);&#125; 答案是不会，调用 foo 会将 foo 函数推入堆栈，在处理内部代码时，js 引擎遇到 setTimeout，将 foo 函数传递给 webapi，并从函数返回，调用栈为空，计数器被设置为 0，foo 被发送到任务队列，由于此时调用栈为空，事件循环将 foo 推入调用栈进行处理，进程再次重复，堆栈不会溢出。 如果控制台中运行以下函数，页面是否会响应123function foo() &#123; return Promise.resolve().then(foo);&#125; 答案是不会响应，微任务队列总是在执行后返回到事件循环前清空，只有在微任务队列为空时，事件循环才会重新渲染。 我们能否以某种方式为下面的语句使用展开运算符而不导致类型错误12var obj = &#123; x: 1, y: 2, z: 3 &#125;;[...obj]; 答案是通过为 obj 添加[Symbol.iterator]函数 12345678910111213obj[Symbol.iterator] = function() &#123; return &#123; next: function() &#123; if (this._countDown === 3) &#123; const last = this._countDown; return &#123; value: last, done: true &#125;; &#125; this._countDown++; return &#123; value: this._countDown, done: false &#125;; &#125;, _countDown: 0 &#125;;&#125;; 运行以下代码片段会打印什么123456var obj = &#123; a: 1, b: 2 &#125;;Object.setPrototypeOf(obj, &#123; c: 3 &#125;);Object.defineProperty(obj, d, &#123; value: 4, enumerable: false &#125;);for (let prop in obj) &#123; console.log(prop);&#125; 答案是 a b c xGetter()会打印什么1234567891011var x = 10;var foo = &#123; x = 90; getX: function() &#123; return this.x; &#125;&#125;foo.getX();var xGetter = foo.getX;xGetter(); 会打印 10, 这里的 this 指向的是全局变量 10]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scattered_knowledge]]></title>
    <url>%2F2019%2F06%2F14%2Fscattered-knowledge%2F</url>
    <content type="text"><![CDATA[如何在vscode中引入轻量级的类型检查机制？ jsDoc了解下。 打开vscode, 按下ctrl+shift+p,输入setting.json,找到对应的“Open Setting.json”,将“javascript.implicitProjectConfig.checkJs”:true配置进去。(默认是false) 打开或关闭检查，可以简单的跳过显示的配置，直接通过在页面顶部引入@ts-check或者@ts-nocheck来实现。 如果项目中有jsconfig.json文件，可以直接在compilerOptions下添加checkJs:true打开TypeScript的检查]]></content>
      <categories>
        <category>碎片小知识</category>
      </categories>
      <tags>
        <tag>开发领域所遇到的零散小知识汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构基础知识]]></title>
    <url>%2F2019%2F06%2F12%2Fdata-structure-00%2F</url>
    <content type="text"><![CDATA[数组的特点： 同等大小元素组成的连续的内存区域，索引是连续的整数。 O(1)访问任意数组的元素 O(1)增加或移除最末尾的元素 O(n)增加或移除任意位置的元素 链表的特点： O(1)从第一个开始插入或移除元素 对于双端链表，O(1)从最后开始插入或移除元素 O(n)的时间找到任意的元素 元素没有必要是连续的 用双端链表插入和移除的时间复杂度是O(1) 二叉树 深度优先 - 优先遍历子树，然后再遍历相邻的兄弟节点。(traverse one subtree before exploring a sibling tree) 广度优先 - 按照树的层级，逐级进行遍历。(travserse one level before processing to next level)]]></content>
      <categories>
        <category>data</category>
      </categories>
      <tags>
        <tag>backend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[removeEventListener不工作了]]></title>
    <url>%2F2019%2F06%2F11%2Fissues-01%2F</url>
    <content type="text"><![CDATA[今天在看一道练习题 然后发现有不少伙伴解题思路很好。模仿了下，发现有个监听事件始终无法被remove。奇怪了，代码里明明remove了那个监听，还是可以被触发。 12345678910111213141516171819202122232425let _handleMove = (evt) =&gt; &#123; var evt = evt.touches&amp;&amp;evt.touches[0] || evt; if (!this.start.length) &#123; this.start = [evt.pageX, evt.pageY]; &#125; let boxes = document.querySelectorAll(&apos;.box&apos;); boxes.forEach((el)=&gt;&#123; if(_isCovered(evt,el)) el.classList.add(&apos;active&apos;); else el.classList.remove(&apos;active&apos;); &#125;); &#125;;let _handleUp = (ev) =&gt; &#123; if (this.start.length) &#123; this.start.length = 0; &#125; else &#123; if (!ev.target.className.includes(&apos;box&apos;)) &#123; clear(); &#125; &#125; window.getSelection().removeAllRanges();//清除选中区域 document.removeEventListener(this.currEvent.move, _handleMove.bind(this)); &#125;; 后面发现是因为bind(this),导致移除的回调函数和之前的不一样所致。 12345678910111213let _handleMove = ((evt) =&gt; &#123; var evt = evt.touches&amp;&amp;evt.touches[0] || evt; if (!this.start.length) &#123; this.start = [evt.pageX, evt.pageY]; &#125; let boxes = document.querySelectorAll(&apos;.box&apos;); boxes.forEach((el)=&gt;&#123; if(_isCovered(evt,el)) el.classList.add(&apos;active&apos;); else el.classList.remove(&apos;active&apos;); &#125;); &#125;).bind(this); 这种细节的东西还是太容易忽视了 https://jsfiddle.net/ryhnatwoods/6dz4psr3/2/]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Polymer 1.x企业级的实现经历(翻译)]]></title>
    <url>%2F2019%2F06%2F11%2Ffanyi-polymer-practice%2F</url>
    <content type="text"><![CDATA[Polymer 1.x企业级的实现经历(http://andrewstacy.com/blog/my-experience-with-polymer-1-at-enterprise-scale-introduction.html) 思考用户行业的特点 大量的特许经营的商店，并且每位私营业主在食品选择和制作，价格的定制上会有很多自主权 大量的产品变动和频繁的更新 需要做什么 需要一个框架，这个框架必须要满足以下的要求 可以即时响应客户需求 通过减少工作量降低公司成本 它可以使团队达到企业级的最佳实践和代码组织水平 需要有很好的文档 在公司快速成长的同时，好的文档是对员工快速适应最好的资源。 需要有高度的模块化作为核心 基于不同店家可以快速的大幅度的改变。 作者在选型时认为web components是未来的趋势，可能当下并不那么被看好。 那么Web Components到底为我们解决了什么问题？ 支持真个美国15000家加盟店 支持每家店不同的菜单界面的配置 支持超1w产品的支持 支持为每家店设置不同的界面布局 支持基于每餐（早，中，晚）的不同样式 基于NTP协议下的图片和高亮文本的同步 基于NTP协议下的菜单界面区域 提供舒适的用户编辑界面 3个月内验收 “Shadow DOM removes the brittleness of building web apps. The brittleness comes from the global nature of HTML, CSS, and JS.” (Bidelman) - 影子树去除了构建web应用中脆弱的东西，而这些脆弱的东西来自于html, css 和 js的天性。 “Shadow DOM fixes CSS and DOM. It introduces scoped styles to the web platform. Without tools or naming conventions, you can bundle CSS with markup, hide implementation details, and author self-contained components in vanilla JavaScript.” (Bidelman) - 影子树完善了css和dom， 它将scoped的样式带入网页平台。不需要借助工具，命名规范，你就可以把css和标签融合在一起，隐藏实现的细节，通过原生js创作独立的组件。 我们可以把web components组件看作是乐高玩具中的一块，我们可以以最小的成本随意的拼装 以下是web components至关重要的几点： HTML Templates Shadow DOM Custom elements HTML imports 项目的结构 Base Components 这个是应用中最小的部分，是最底层的一个单元，比如base-header,base-product-table, base-image-rotator等等 Region Components 这些是由基础单元组成的组合组件，提供整个菜单页中某一个区域的可视化部分 Layout Components 这些事控制区域组件需要在什么位置去展示的组件，它也是菜单页中的一部分 Master Components 这个是一个入口的组件包含页面所有可视化的部分，它是基于设备来选择布局]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>polymer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mianshi_miaoyin]]></title>
    <url>%2F2019%2F06%2F10%2Fmianshi-miaoyin%2F</url>
    <content type="text"><![CDATA[笔试题目： css部分 清除浮动效果 如何让200x200的div垂直居中js部分 用js写一个对数组排序的函数 如何理解js的模块化，以及模块化带来的好处 如何理解异步，有什么简单的异步实现？ 请写出js新建一个对象的过程 面试部分： 先是自我介绍以及项目介绍 js基础，异步，代理机制，vue的双向绑定的原理，原型链，es6相关知识点，async, await, promise 页面优化 java基础]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务分布式事务Saga模式简介]]></title>
    <url>%2F2019%2F06%2F07%2Fmicroservice-saga%2F</url>
    <content type="text"><![CDATA[微服务分布式事务Saga模式简介(转载)[https://www.jdon.com/49307] 在微服务环境下为什么不能用ACID事务？因为每个微服务都有自己得数据库，比如订单服务有自己的订单数据库，而客户服务有自己的客户数据库，如果有个业务需要跨订单和客户一起操作，那么一般使用JTA+XA方式跨订单数据库和客户数据库。 123456789101112131415@ Transactional //事务元注解public void crossAction(XX)&#123; //事务开始 //这里ORDERS是属于订单服务的私有数据库 SELECT ORDER_TOTAL FROM ORDERS WHERE CUSTOMER_ID = ? //这里CUSTOMERS是属于客户服务的私有数据库 SELECT CREDIT_LIMIT FROM CUSTOMERS WHERE CUSTOMER_ID=? INERT INTO ORDERS ..... //提交事务&#125; 以上JTA操作如果结合XA数据源配置，将会实现2PC两段事务提交。 通过这段事务操作主要目的是为了维持业务上的不变性约束，比如一个人下订单的总金额不能超过这个人的信用卡授信额度，也就是说：一个人购买的商品总金额只能小于或等于他的信用卡授信额度。 但是，2PC两段提交并不是微服务分布式架构的选择，因为存在单点风险，因为锁也会降低吞吐量。分布式事务如果不结合CAP定理是无法认识清楚，2PC其实只是选择了CAP中CA，虽然CA保证了可靠性，但是忽视网络通讯随时可能堵塞或失败，形成网络分区，反而不可靠，2PC带来的可靠性在分布式环境中是虚幻的。 在分布式系统中，CAP定理是King，CAP定理无论是理论高度或是工程实施高度都是要高于传统事务的，在CAP定理的干预下，传统ACID事务走向了妥协，变成了BASE，也就是走向最终一致性的柔性事务。 Saga是来自于1987年Hector GM和Kenneth Salem论文，从原理上看Saga好像比较简单： 客户端发出订单创建请求createOrder() OrderService会在其内部本地事务进行Order数据库操作，此时订单状态是待确认状态。 CustomerService会在其内部本地事务进行信用卡预授权操作，检查订单金额是否超过信用卡授信额度？ OrderService会在上一步确认业务不变性约束得到满足后，再次操作订单数据库状态，将订单状态改为确认状态。 但是，传统2PC/ACID事务中在上面任何一个步骤失败时会使用回滚操作，比如第三步出错，因为是两段提交，所以，第二段就不会进行确认提交，而是进行回滚Rollback，这样订单状态就恢复到当前事务之前的状态，但是在Saga这种BASE模式下,是无法实现像2PC回滚的，因为2PC是同步的，而Saga是异步的。 那么在Saga这种异步模式如何实现客户的及时响应呢？有两种可选方案：首先是当Saga流程全部完成时再发送响应，这样的好处是响应中带有处理结果，但是这样会降低可用性，CAP定理中，分布式环境中满足了C一致性，只能降低了可用性A。 第二种方案是推荐的，也就是在创建Saga之时，并不是等这个Saga流程完成时候，就发送响应给客户端，当然客户端可能只会得到一个事务ID号，并没有得到如期的处理结果，但是这样数据一致性比较弱的情况下，我们能获得很高的可用性A。 客户端可以根据事务ID号再次查询处理结果（通过浏览器异步调用或服务器端推送都可以），比如之前调用createOrder()，获得order的id，然后，根据这个id号调用getOrder(id)，这样就能获得自己创建的订单。在传统同步环境下，这两步其实是在同一个步骤实现的，也就是createOrder()的结果就是一个订单order。 通过UI界面设计可以降低这种不一致性导致的延迟体验： UI会通过异步方式进行查询调用，给用户的体验感觉还是创建订单后返回了一个创建好的订单 Saga处理也是可以很快的，小于100毫秒。 如果会花费很长时间，可以显示“正在处理中…” Saga处理完成后可以采取服务器推送结果到浏览器。 Saga是否实现了ACID？ ACID是原子性 一致性 隔离性和持久性的总称： 原子性是确保事务中所有步骤要么全部完成，要么全部撤销回滚。Saga可以在事务中任何一个步骤发生失败时，通过调用应用服务的回滚接口实现撤销。 一致性其实是数据的完整性，这个可以由一个应用服务内部的本地事务通过数据库机制完成，跨服务的完整性(Referential integrity)由应用完成。 持久性Durability是由本地事务完成。 下面就剩下关键的隔离性，隔离性能够保证每个事务独立进行，不互相干扰，是与并发控制有关的，缺乏隔离性，会造成脏读 或者数据重复 更新丢失等问题。 在Saga中解决隔离性的策略可通过两种方式： 可交换的更新(Commutative updates), 比如借方帐户可以看成是贷方帐户的补偿 版本化，记录状态改变的历史记录，这些改变是可以交换的， 这其实是非常类似Event Sourcing事件溯源。 通过引入事件溯源能够实现很好的隔离性，因为回避了状态的实时并发修改，而是将这些修改动作作为事件记录下来，而是在状态需要读取时，对修改动作一个个进行播放，从而更新状态值到最新状态，也就是说，事件溯源回避了对状态的并发写操作，而是在读操作时进行状态实时计算。 比如a的初始状态是1，有三个修改动作：加入了100，减去了50，加入了20，事件溯源是将这三个动作作为事件先记录下来，并不是立即计算a的最终状态，而是当有状态读取动作时，遍历事件集合进行计算：1+100-50+20=71，客户端会获得a的最终状态是71。 Saga的两个形态 Saga有两个方式：Orchestration(有中心协调者)和Choreography(无中心协调者)。 Orchestration：各个服务围绕一个协调中心点，类似乐队需要一个指挥。 和Choreography：各个服务之间没有一个协调点，靠服务自己相互直接协调，如果跳集体舞一样(当然有时会有一个领舞者，但是不明显)。 无中心协调者的Saga方式需要使用事件概念，比如订单服务发布订单创建事件到客户服务那里，客户服务发布授信通过或不通过事件给订单服务。引入事件概念可能会增加业务应用开发的难度，除非业务应用时遵循DDD领域事件开发方式。 有中心协调者的Saga方式需要可能存在协调者本身失败的单点风险，但是能够方便减轻业务应用的开发量，能够形成Saga框架，由框架自己管理流程前进和回退。 比如以Eventuate Tram Saga框架代码应用为例，它定义了流程下一步和上一步补偿的各个业务动作： 12345678SagaDefinition&lt;CreateOrderSagaData&gt; sagaDefinition = step() .withCompensation(this::reject) .step() .invokeParticipant(this::reserveCredit) .step() .invokeParticipant(this::approve) .build(); withCompensation是定义回退补偿动作，这里补偿是当前类的reject方法，而流程前进有两步：reserveCredit和approve两个方法。 reserveCredit方法其实是进行信用卡授信额度验证的动作，发送一个ReserveCreditCommand命令到客户服务： 12345678910private CommandWithDestination reserveCredit(CreateOrderSagaData data) &#123; long orderId = data.getOrderId(); Long customerId = data.getOrderDetails().getCustomerId(); Money orderTotal = data.getOrderDetails().getOrderTotal(); return send(new ReserveCreditCommand(customerId, orderId, orderTotal)) .to(&quot;customerService&quot;) .build(); &#125; 而客户服务则监听这个命令形式的消息： 1234SagaCommandHandlersBuilder .fromChannel(&quot;customerService&quot;) .onMessage(ReserveCreditCommand.class, this::reserveCredit) .build();]]></content>
      <categories>
        <category>microservice</category>
      </categories>
      <tags>
        <tag>saga</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银行中后台与阿里中后台有何不同-读后感]]></title>
    <url>%2F2019%2F06%2F07%2Fgeektime-thinking-forbank-01%2F</url>
    <content type="text"><![CDATA[银行中后台与阿里中后台有何不同-读后感文章来自于极客时间（https://time.geekbang.org/column/article/99731） 大体内容如下：阿里的中台提高了服务的服用能力和开发效率，银行是否可以借鉴阿里构造通用框架？如果可行，那么需要注意什么？假设可行的情况下: 解决的是流程问题。 对于流程的抽象。 阿里具有行业业务的通用性很高，流程的高度可控性，可替换性。总之电商领域实在比较接近的流程下去寻找能力和服务上的特色 银行领域，虽然产品的同质化程度很高，但受制于行业本身的原因，各大银行的流程无法统一，原因在于以下几点 组织结构和部门利益 部门设置和职位边界在这种背景下，银行的中台更多的是面向功能的沉降，在流程与功能解耦的原则下，将流程分离成微服务架构层但是剥离可通用的能力作为中台服务层。 银行多以产品驱动，设计上其实并不是一定要以“客户为中心”这种导向而改变，因为产品即服务，服务即产品，并不需要太纠结（这个说法个人不太赞同）产品通常意味着会驱动后台一些列服务和功能。在ESB下，这是不同服务间的信息流转。在没有大并发量及其严重堵塞的情况下，没有必要拿掉ESB。微服务和ESB是否互斥业界也是有不同声音的，消息队列下，其实一个产品就意味着相关服务的一组订阅发布。可以将银行的产品按照较大的流程环节进行微服务切分，这种流程可能会在不同的银行间有差别，譬如，对某个业务A银行有预处理过程，而B银行没有。某个业务A银行可以1个部门完成，B银行需要几个部门协作完成。这些差异也许来自内部文化，也许来自规模。银行自己也会随规模和业务重点的变化而不断调整，其实提供的服务变化不大，但是流程可能变化巨大，所以流程环节设计成微服务层以满足快速变化。（部分观点不太赞成）将相对稳定的功能，比如示例中的久期计算，缺口计算之类的较为通用，和评级计算，EVA这样相对有变化但不需要非得和流程搅在一起的功能沉降为中台，服务尽可能无状态以便于改造和迁移。数据则是企业级后台。微服务的处理结果准时更新至企业级数据库，中台可以通过企业级数据库查询准时数据，实时数据则可由调用方提供。银行学习互联网还应考虑一致性设计原则，阿里采用的是最终一致，银行采用的是强一致。从企业文化和组织结构角度看，阿里的技术成长伴随阿里的文化共同成长。对于银行企业文化来说，应该还是很有挑战性的。 以下是我读过这篇文章的感受。 以客户为中心的设计，我觉得是跨行业的，跨规模的，也是企业是生存，发展，壮大的关键。就比如银行，银行提供的产品或者说服务，一定是迎合客户需求的，可以是定制高端，也可以是面向大众的。没有市场基础，不被市场认可的产品，注定会被市场所淘汰。 银行采用溯源策略和最终一致能否替代强一致？至少在UI设计上是可以分阶段显示状态，增强用户体验。 可移植的银行UI脚手架+定制化的银行主题+可扩展的功能UI，实现银行ui在PC,移动端的第三方化。 值得学习得微服务视频 https://microservices.io/microservices/news/2017/12/04/qconsf2017-presentation.html]]></content>
      <categories>
        <category>头脑风暴</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学advanced-react]]></title>
    <url>%2F2019%2F06%2F06%2Fadvanced-react%2F</url>
    <content type="text"><![CDATA[深入JSX 本质上来讲，JSX只是为React.createElement(Component, props, …children)提供的语法糖指定react的元素类型 react必须声明 react可以用点表示法或取，某个组件中的子组件 首字母大写，区别html原生标签 在运行时选择类型，需要先将类型赋值给大写的变量，不支持表达式形式的标签名属性 使用js表达式 字符串常量，当传递一个字符串常量时，该值会被解析为HTML非转义字符串。 当没有给属性传值时，默认为true 扩展属性JSX子代的表现形式 字符串常量 JSX js表达式 函数 布尔，null和undefined都是有效子代，但是不会被渲染 如果你想让类似 false、true、null 或 undefined 出现在输出中，你必须先把它转换成字符串 使用PropTypes进行类型检查注意: React.PropTypes 自 React v15.5 起已弃用。请使用 prop-types 库代替。 具体参考https://www.reactjscn.com/docs/typechecking-with-proptypes.html 静态类型检查 Flow针对js代码的静态类型检查器。 为了使用 Flow, 你需要：将 Flow 添加到您的项目作为依赖项。确保编译后的代码中去除了 Flow 语法。添加了类型注释并运行 Flow 来检查它们。 在一个项目中添加flow 12npm install --save-dev flow-binnpm run flow init 从编译后的代码中剥离Flow Create React App如果你的项目是使用 Create React App 建立的，恭喜！ Flow 此时已经被默认剥离，所以在这一步你不需要做任何事情。 配置Babel 1npm install --save-dev babel-preset-flow 然后将 flow preset 加入你的 Babel 配置。比如，如果你通过 .babelrc 文件配置 Babel，它可能会如下所示 123456&#123; &quot;presets&quot;: [ &quot;flow&quot;, &quot;react&quot; ]&#125; Flow 不需要 react preset，但他们经常在一起使用。 Flow 本身就理解 JSX 语法。 运行flow 1npm run flow 添加Flow注释 配置TypeScript的过程差不多，文档很详细https://www.reactjscn.com/docs/static-type-checking.html Refs和DOM Refs提供了一种访问在render方法中创建的DOM和react元素的方式 在典型数据流外强制修改子组件为react组件的实例 在典型数据流外强制修改子组件为DOM元素何时使用Refs 处理焦点，文本选择或媒体控制 触发强制动画 集成第三方DOM库不要过度使用Refs，如果可以,状态提升是更适合的做法。创建Refs React.createRef()创建refs，通过ref属性获得react元素访问Refs 当一个ref属性被传递给一个render函数中的元素，可以使用ref中的current属性对节点引用进行访问 当ref属性被用于普通html，React.createRef()将接收底层DOM元素作为它的current属性对节点的引用进行访问 当ref属性被用于一个自定义类组件时，ref对象将接收该组件已挂载的实例作为它的current 不能在函数式组件上使用ref属性，因为没有实例 为DOM元素添加Ref undefined React会在组件加载时将DOM元素传入current属性，在卸载时则会改为null。ref的更新会发生在componentDidMount或componentDidUpdate生命周期之前。也可以在函数式组件内部使用ref，只要其指向DOM或者自定义组件 undefined 对父组件暴露DOM节点 在极少数情况下你可能希望从父组件访问子节点的dom节点处理的方案有以下几种 Ref 转发使组件可以像暴露自己的 ref 一样暴露子组件的 ref。 将 ref 作为特殊名字的 prop 直接传递。 findDOMNode()，但是不推荐。回调Refs 函数接受React组件的实例或是HTML DOM元素作为参数，用以存储和被访问 如果 ref 回调以内联函数的方式定义，在更新期间它会被调用两次，第一次参数是 null ，之后参数是 DOM 元素。这是因为在每次渲染中都会创建一个新的函数实例。因此，React 需要清理旧的 ref 并且设置新的。通过将 ref 的回调函数定义成类的绑定函数的方式可以避免上述问题，但是大多数情况下无关紧要。 性能优化更新UI时，React在内部使用几种巧妙的技术来优化DOM操作数量，对应用来说，使用react不需要做太多的优化工作就可以快速创建用户界面。除此之外，还有一些优化react应用性能的办法。 使用生产版本使用chrome performance归档组件 https://building.calibreapp.com/debugging-react-performance-with-react-16-and-chrome-devtools-c90698a522ad避免重复渲染 React在渲染出的UI内部简历和维护了一个内层的实现方式，它包括了从组建返回的react元素。这一层实现就称为虚拟dom。当一个组件的props和state改变时，react通过新返回的元素和之前渲染的元素作比较来决定是否更新dom。在某些情况下，可以重写生命周期函数shouldComponentUpdate通过返回false直接跳过比较和渲染阶段从而提升速度。 SCU表明了shouldComponentUpdate的返回内容，vDOMEq表明了待渲染的React元素与原始元素是否相等。如果状态是对象类型，请创建一个新的对象包含变得内容，这样才能保证react可以正确比较和渲染。另外immutable.js是解决这个问题的另一种方法，它通过结构共享提供不可变的，持久的集合。 不可突变:一旦创建，集合就不能在另一个时间点改变。 持久性:可以使用原始集合和一个突变来创建新的集合。原始集合在新集合创建后仍然可用。 结构共享:新集合尽可能多的使用原始集合的结构来创建，以便将复制操作降至最少从而提升性能。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react-basic]]></title>
    <url>%2F2019%2F06%2F06%2Freact-basic%2F</url>
    <content type="text"><![CDATA[条件渲染 在react中，你可以通过状态的变化选择显示不同的组件。使用js的if或是条件运算符来完成。具体的例子可以参考文档中提到的https://www.reactjscn.com/docs/conditional-rendering.html逻辑与运算符(&amp;&amp;)和三目运算符通过在render函数中返回null来阻止渲染。它不会影响组件生命周期的回调。 列表与keys 渲染多个组件，可以通过{}在jsx内构建一个元素集合。基础列表组件，在出现有多个相同react元素时，react内部通过特殊属性key来识别哪个元素发生变化元素key只有它和它的兄弟节点对比时才有意义，并且这个是唯一的。key这个特殊属性无法传递给组件，需要将传递给那些可被传递的属性。JSX允许{}中嵌入任何表达式。 表单 react负责渲染表单的组件仍然控制用户后续输入说发生的变化。相应的，其值由react控制的输入表单元素称为受控组件。 说白了，就是react创建的这个form表单，它会去控制状态，更新输入输出值，然后再传递给子组件，这种情况下子组件就是受控组件，是不是有点束手束脚的感觉？ 常见的一个内置的受控组件有input,textarea,select etc, 但这里有个特殊情况是当input的type=”file”,他是react中的一个非受控组件https://reactjs.org/docs/uncontrolled-components.html#the-file-input-tag。多个输入的解决办法是通过给每一个元素添加name属性来实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Reservation extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isGoing: true, numberOfGuests: 2 &#125;; this.handleInputChange = this.handleInputChange.bind(this); &#125; handleInputChange(event) &#123; const target = event.target; const value = target.type === &apos;checkbox&apos; ? target.checked : target.value; const name = target.name; this.setState(&#123; [name]: value &#125;); &#125; render() &#123; return ( &lt;form&gt; &lt;label&gt; Is going: &lt;input name=&quot;isGoing&quot; type=&quot;checkbox&quot; checked=&#123;this.state.isGoing&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; Number of guests: &lt;input name=&quot;numberOfGuests&quot; type=&quot;number&quot; value=&#123;this.state.numberOfGuests&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt; ); &#125;&#125; 当您将预先存在的代码库转换为React或将React应用程序与非React库集成时，这可能变得特别烦人。在以上情况下，你或许应该看看非受控组件，这是一种表单的替代技术。 状态提升 有时候遇到需要几个组件共享状态数据的情况，这个时候就需要将状态从子组件中剥离出来提升至他们最近的父组件中进行管理。 1234567891011121314151617181920212223242526272829303132333435363738394041class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = &#123;temperature: &apos;&apos;, scale: &apos;c&apos;&#125;; &#125; handleCelsiusChange(temperature) &#123; this.setState(&#123;scale: &apos;c&apos;, temperature&#125;); &#125; handleFahrenheitChange(temperature) &#123; this.setState(&#123;scale: &apos;f&apos;, temperature&#125;); &#125; render() &#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === &apos;f&apos; ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === &apos;c&apos; ? tryConvert(temperature, toFahrenheit) : temperature; return ( &lt;div&gt; &lt;TemperatureInput scale=&quot;c&quot; temperature=&#123;celsius&#125; onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt; &lt;TemperatureInput scale=&quot;f&quot; temperature=&#123;fahrenheit&#125; onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(celsius)&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 编辑输入框所发生的基本流程 React在DOM原生组件input上调用指定的onChange函数。在本例中，指的是TemperatureInput组件上的handleChange函数。 TemperatureInput组件的handleChange函数会在值发生变化时调用this.props.onTemperatureChange()函数。这些props属性，像onTemperatureChange都是由父组件Calculator提供的。 当最开始渲染时，Calculator组件把内部的handleCelsiusChange方法指定给摄氏输入组件TemperatureInput的onTemperatureChange方法，并且把handleFahrenheitChange方法指定给华氏输入组件TemperatureInput的onTemperatureChange。两个Calculator内部的方法都会在相应输入框被编辑时被调用。 在这些方法内部，Calculator组件会让React使用编辑输入的新值和当前输入框的温标来调用this.setState()方法来重渲染自身。 React会调用Calculator组件的render方法来识别UI界面的样子。基于当前温度和温标，两个输入框的值会被重新计算。温度转换就是在这里被执行的。 接着React会使用Calculator指定的新props来分别调用TemperatureInput组件，React也会识别出子组件的UI界面。 React DOM 会更新DOM来匹配对应的值。我们编辑的输入框获取新值，而另一个输入框则更新经过转换的温度值。需要注意的几点： 始终保持自上而下的数据流，当自组件的状态需要被其他兄弟组件获得，那么你就需要把控制权交出来给临近的父节点，如果是夸了好几个父节点的话，目前的话，你就必须把状态控制权一直往提交。在我看来并不是一个很好的设计思想，因为有的状态可能只是给少数几个组件，只不过组件之间跨越了不同层级关系。 状态提升比双向绑定方式要写更多的“模版代码”，但带来的好处是，你也可以更快地寻找和定位bug的工作。因为哪个组件保有状态数据，也只有它自己能够操作这些数据，发生bug的范围就被大大地减小了。此外，你也可以使用自定义逻辑来拒绝或者更改用户的输入。 如果某些数据可以由props或者state提供，那么它很有可能不应该在state中出现。举个例子，我们仅仅保存最新的编辑过的temperature和scale值，而不是同时保存 celsiusValue 和 fahrenheitValue 。另一个输入框中的值总是可以在 render() 函数中由这些保存的数据计算出来。这样我们可以根据同一个用户输入精准计算出两个需要使用的数据。 当你在开发UI界面遇到问题时，你可以使用 React 开发者工具来检查props属性，并且可以点击查看组件树，直到你找到负责目前状态更新的组件。这能让你到追踪到产生 bug 的源头。 组合vs继承 React具有强大的组合模型，建议多使用组合而不是继承包含关系，一些组件不能提前预知子组件是什么的情况下可以使用 123456789101112131415161718192021222324function SplitPane(props) &#123; return ( &lt;div className=&quot;SplitPane&quot;&gt; &lt;div className=&quot;SplitPane-left&quot;&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className=&quot;SplitPane-right&quot;&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;//这里我们可以看到react元素本身也可以作为props传递给子组件function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; );&#125; 至于继承？ 在 Facebook 网站上，我们的 React 使用了数以千计的组件，然而却还未发现任何需要推荐你使用继承的情况。 属性和组合为你提供了以清晰和安全的方式自定义组件的样式和行为所需的所有灵活性。请记住，组件可以接受任意元素，包括基本数据类型、React 元素或函数。 如果要在组件之间复用 UI 无关的功能，我们建议将其提取到单独的 JavaScript 模块中。这样可以在不对组件进行扩展的前提下导入并使用该函数、对象或类。 React理念 react的初衷是想使用js创建大型且快速响应的web应用如何快速创建react UI 把 UI 划分出组件层级 用 React 创建一个静态版本 定义 UI 状态的表示 确定你的 State 应该位于哪里找出哪一个是 state。每个数据只要考虑三个问题： 它是通过 props 从父级传来的吗？如果是，他可能不是 state。它随着时间推移不变吗？如果是，它可能不是 state。你能够根据组件中任何其他的 state 或 props 把它计算出来吗？如果是，它不是 state。 添加反向数据流]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react_event]]></title>
    <url>%2F2019%2F06%2F05%2Freact-event%2F</url>
    <content type="text"><![CDATA[事件处理 react元素的事件处理和dom元素处理事件有一点语法不同 react绑定属性的命名采用驼峰式写法 如果是JSX的语法，你需要传入的是函数而不是字符串 在react中必须显示使用preventDefault函数去阻止默认的行为 为一个元素初始渲染时提供一个监听器 需要谨慎对待回调函数的this指向。通常情况下，如果你没有在方法后面添加 () ，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。如果你没有使用属性初始化器语法，你可以在回调函数中使用箭头函数。 向事件处理函数传递参数 分别通过 arrow functions 和 Function.prototype.bind 来为事件处理函数传递参数通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react_state_lifecycle]]></title>
    <url>%2F2019%2F06%2F05%2Freact-state-lifecycle%2F</url>
    <content type="text"><![CDATA[将函数转化成类 为什么要把函数转化成类？为了让组件拥有局部更新能力类中状态的特点？状态是私有的，完全受控于当前的组件，定义为类的组件有些特性，局部状态就是如此。 有一个改写clock组件的例子 这个例子很详细，直接上(链接)[https://www.reactjscn.com/docs/state-and-lifecycle.html] 正确使用状态 这个知识点很关键的。 要用setState方法更新state的状态，构造函数是唯一能够初始化state的地方 当状态更新可能是异步的时候，需要接收的是一个函数而不是对象。函数可以异步调用的。 状态更新合并，它可以分离的更新相应的状态里面的部分。这里的合并是浅合并，也就是说this.setState({comments})完整保留了this.state.posts，但完全替换了this.state.comments。 123456789101112131415161718192021constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;; &#125;componentDidMount() &#123; fetchPosts().then(response =&gt; &#123; this.setState(&#123; posts: response.posts &#125;); &#125;); fetchComments().then(response =&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;); &#125; 数据自顶向下流动 父组件和子组件都不能知道某个组件是状态还是无状态，并且它也不应该关心某个组件被定义为一个类还是一个函数。状态可以作为属性传递给子组件这通常称之为自顶向下或是单向数据流，任何状态始终有某一个特定组件持有，从该状态导出的任何数据或是UI都只影响树中下方的组件。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react-component-props]]></title>
    <url>%2F2019%2F06%2F05%2Freact-component-props%2F</url>
    <content type="text"><![CDATA[组件&amp;props 组件可以将UI切割成独立可复用的部件。组件即函数，它接收任意的输入值，并返回需要展示的react元素 123456789function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;ReactDOM.render( element, document.getElementById(&apos;root&apos;)); 组件名必须大写，个人认为组件其实就是对象，对象名称一般都以大写开头，所以这里是要大写开头哦。 组合组件 就是多个子组件拼凑自由组合在一起。 组件返回值只有一个根元素 提取组件 对于大型应用，多场景的情况，越小的组件也代表越大的灵活性，这允许我们像乐高玩具那样拼搭成我们喜欢的样子。而且这些小的组件还可以反复的利用。 Props的只读性 所有的react都必须像纯函数那样使用它们的props, 也就是你无论输入多少次一模一样的参数，它返回的结果应该都是一样的。是不是感觉有点幂等性的意思]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react-元素渲染]]></title>
    <url>%2F2019%2F06%2F05%2Freact-render-element%2F</url>
    <content type="text"><![CDATA[元素渲染 在react中，元素被当作react应用的最小单元，小到它可以是一个静态的div对象，大到它可以由许许多多小的组件汇聚而成。一般而言，如果一开始就是使用react开发的页面，那只会有一个react的容器去包裹。但是如果你是在其他项目中部分的引入react的组件，那么就可能会有多个容器存在。从更新元素渲染的角度，react元素在没有设置状态的情况下是不可变的，他就好像是过去某一个时间节点一样，你没法回到过去，不是? 但是确实react留下了把开启时间之门的钥匙，只不过是另一种方式的获取。 123456789101112//在这例子中，定时器每隔1s都会重新渲染整个react元素并添加到浏览器的dom树中。是不是感觉很累，就好像每次写错一个单词，老师都得让你罚抄整篇课文，好不爽。function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render(element, document.getElementById(&apos;root&apos;));&#125;setInterval(tick, 1000); react dom,一个可以开启时间钥匙之门的神，它会帮我们只更新那些需要更新的内容，为我们节约了成本和时间]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react-jsx]]></title>
    <url>%2F2019%2F06%2F05%2Freact-jsx%2F</url>
    <content type="text"><![CDATA[JSX简介 首先强调一下JSX不是HTML，它是一种javascript的语法扩展，这种语法的好处是可以和js无缝对接，你可以赋值给变量，你也可以直接在里面通过{}包裹去执行js表达式。不过文中特别提到为了增加代码的可读性，最好是在JSX代码外面包裹一层()。JSX支持标签的嵌套，允许表达式值的属性，属性通过小驼峰命名来定义JSX能有效防止xss攻击，因为在渲染前，它会将所有内容转换成字符串。JSX代表Object，BABEL转译器会把JSX转换成一个名为React.createElement()的方法调用，最终会返回一个react对象 1234567const element = &#123; type: &apos;h1&apos;, props: &#123; className: &apos;greeting&apos;, children: &apos;Hello, world&apos; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react-Hello World]]></title>
    <url>%2F2019%2F06%2F05%2Freact-hello-world%2F</url>
    <content type="text"><![CDATA[学习下用react来写hello world 首先需要引入react库，可以是通过script标签，也可以通过其他方式。效果可以在(jsFiddle)[https://jsfiddle.net/ryhnatwoods/d1584pe0/1/]上面看。 12ReactDOM.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;app&apos;))]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react]]></title>
    <url>%2F2019%2F06%2F05%2Fzixue-react-01%2F</url>
    <content type="text"><![CDATA[跟着react官方文档自学_01On nous apprend à vivre quand la vie est passée. - Michel De Montaigne 当舒适的生活远离我们而去的时候，我们真的需要重新审视下自己，学习去适应新的生活。 点击进入react中文网首页React支持IE9和IE9+，和其他版本的浏览器。只不过需要polyfills 三个关键字很亮眼。 声明式：按照我的理解是我看到这个标签就知道这个标签作用在页面上的结果，很直观和简洁。不是很明白来自官网的解释“可以让你的代码更加可靠，且方便调试。” 组件化：创建好用有各自状态的组件，页面由一个一个组建搭配而成，感觉和乐高有点类似，很喜欢这种风格。 一次学习，随处编写：无论你现在正在用什么技术栈，你都可以随时引入react开发新特性。这个解释说实在我现在还有点懵 首页分享了分享了4个实例，感觉还不错。 组件：react组件使用render()函数构造组建显示的内容，输入的数据通过this.props传入render函数。 12345678910111213141516//这里首先构造一个HelloMessage的component对象，他接收name的属性对应的数据去返回一个react元素class HelloMessage extends React.Component &#123; render() &#123; return ( &lt;div&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125;&#125;//ReactDOM作为一个最外层的接口，将helloMessage元素渲染好添加到指定dom的容器中，并返回这个组件的引用。//其实它还有个可选的参数callback，可以在渲染更新后执行，具体可以看[render](https://www.reactjscn.com/docs/react-dom.html#render)ReactDOM.render( &lt;HelloMessage name=&quot;Taylor&quot; /&gt;, mountNode); 有状态的组建 除了使用外部传入的数据以外，组件还可以拥有其内部使用的状态数据，这个是通过this.state访问状态数据的，当组件状态发生改变时，会调用render方法重新渲染。 123456789101112131415161718192021222324252627282930313233343536//这个看名字是个计时器组件，在构造它时有个初始化的状态对象，0秒。它有一个读秒的方法，这个方法每调用一次会改变组件当前的状态，也就是+1秒。//这里你会发现组件中出现了两个生命周期的钩子函数，具体生命周期，可以看下[掘金这篇](https://juejin.im/post/5a062fb551882535cd4a4ce3).我先了解这个例子里的两个。//componentDidMount：组件已经渲染到页面后触发，此时页面中有了真正的DOM元素，可以进行DOM相关的操作//componentWillUnmount：组件销毁时被处罚，这里我们可以做一些清理的工作class Timer extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; seconds: 0 &#125;; &#125; tick() &#123; this.setState(prevState =&gt; (&#123; seconds: prevState.seconds + 1 &#125;)); &#125; componentDidMount() &#123; //这里设置了一个定时器，每隔1是自动调用tick函数更新组件状态 this.interval = setInterval(() =&gt; this.tick(), 1000); &#125; componentWillUnmount() &#123; //组件销毁时，清理掉定时器 clearInterval(this.interval); &#125; render() &#123; return ( &lt;div&gt; Seconds: &#123;this.state.seconds&#125; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Timer /&gt;, mountNode); 简单的TODO应用 这里简单的混合使用了props和state去创建了一个todo的应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//这里还是构造了一个todo的react组件，在构造过程中我们发现，继承了父类构造函数，初始化组件状态，此组件有两个可变状态，待办事项列表也就是那个items，另一个是用户输入的文本内容，也就是text。这里还初始化了两个针对这个组件的用户行为，一个是绑定在onchange事件上的handleChange回调，另外一个是绑定在onSubmit时间上的handleSubmit回调。class TodoApp extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; items: [], text: &apos;&apos; &#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; render() &#123; return ( &lt;div&gt; &lt;h3&gt;TODO&lt;/h3&gt; &lt;TodoList items=&#123;this.state.items&#125; /&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;button&gt; Add #&#123;this.state.items.length + 1&#125; &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); &#125; handleChange(e) &#123; this.setState(&#123; text: e.target.value &#125;); &#125; handleSubmit(e) &#123; e.preventDefault(); if (!this.state.text.length) &#123; return; &#125; const newItem = &#123; text: this.state.text, id: Date.now() &#125;; this.setState(prevState =&gt; (&#123; items: prevState.items.concat(newItem), text: &apos;&apos; &#125;)); &#125;&#125;//创建了一个显示所有待办事项的列表组件class TodoList extends React.Component &#123; render() &#123; return ( &lt;ul&gt; &#123;this.props.items.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; ); &#125;&#125;ReactDOM.render(&lt;TodoApp /&gt;, mountNode); 在组件中使用第三方的库 这个是利用第三方的库(Remarkable)实现一个markdown的编辑器 123456789101112131415161718192021222324252627282930313233343536class MarkdownEditor extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123; value: &apos;Type some *markdown* here!&apos; &#125;; &#125; handleChange(e) &#123; this.setState(&#123; value: e.target.value &#125;); &#125; getRawMarkup() &#123; const md = new Remarkable(); return &#123; __html: md.render(this.state.value) &#125;; &#125; render() &#123; return ( &lt;div className=&quot;MarkdownEditor&quot;&gt; &lt;h3&gt;Input&lt;/h3&gt; &lt;textarea onChange=&#123;this.handleChange&#125; defaultValue=&#123;this.state.value&#125; /&gt; &lt;h3&gt;Output&lt;/h3&gt; &lt;div className=&quot;content&quot; //这个属性是react dom自有的，用来替换innerHTML,详情请看[官网文档](https://www.reactjscn.com/docs/dom-elements.html) dangerouslySetInnerHTML=&#123;this.getRawMarkup()&#125; /&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;MarkdownEditor /&gt;, mountNode); 总结 中文react官网的第一页看完了，让我们继续深入探索react吧]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter学习]]></title>
    <url>%2F2019%2F06%2F04%2Fflutter-learn-01%2F</url>
    <content type="text"><![CDATA[跟着技术胖学flutter 小技巧：在vscode上通过flutter run开启flutter应用。press r means hot reloadTo toggle the widget inspector (WidgetsApp.showWidgetInspectorOverride), press “i”.To toggle the display of construction lines (debugPaintSizeEnabled), press “p”.To simulate different operating systems, (defaultTargetPlatform), press “o”.To toggle the elevation checker, press “z”.To display the performance overlay (WidgetsApp.showPerformanceOverlay), press “P”.To enable timeline events for all widget build methods, (debugProfileWidgetBuilds), press “a”To save a screenshot to flutter.png, press “s”.To repeat this help message, press “h”. To detach, press “d”; to quit, press “q”. 学习地址： https://juejin.im/post/5c452bac6fb9a049af6d919a https://jspang.com/posts/2017/01/11/all-video-list.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式和发布订阅模式]]></title>
    <url>%2F2019%2F06%2F04%2Fobserver-pub-sub%2F</url>
    <content type="text"><![CDATA[记录下自己对观察者模式和发布订阅模式的理解，以及自己的一点思考。 首先两者都采用的是监听机制，即某件关注的事务发生变化时，就会通知对此感兴趣的一方去做相应的处理。 观察者模式在我看来更关注观察的对象，当对象发生改变，就会相应的通知对象中维护的那些监听者或者说依赖方去按照自己的方式处理改变了的对象信息，观察对象和观察者是一种强依赖的关系。感觉有点gossip girl的感觉，一举一动都活在公众的视野下，好没有隐私啊。 发布订阅模式在我看来更注重的是发布者，但是相比与观察者模式会多一层叫事件中心，你也可以看作是一个平台，就好比一个舞台，明星想来开演唱会，喜欢这个明星的粉丝们想来听演唱会。那么这里明星就是发布者，粉丝就是订阅者。当然啦，较真的人可能会认为明星的经纪人才是真正的发布者，他们才是和举办场地做沟通的人，那个这又扯远了，这个就扯到代理模式了。那么明星发布演唱会，他会把这个信息传递给舞台方也就是举办方，举办方收到消息就会通知所有关注这个消息的粉丝群体。通过这种方式解耦发布者和订阅者。 观察者是单向的，发布订阅是双向的。其实再仔细琢磨下，这个舞台可以做演唱会，可以做联欢晚会，可以做运动会，可以做拍卖会，等等这个舞台的功能有很多，每种舞台适合不同的观众群体，发布者可以根据适合的主题发布活动，订阅者也可以根据自己喜欢的主题订阅。]]></content>
      <categories>
        <category>pattern</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控制DOM的几种js方法]]></title>
    <url>%2F2019%2F06%2F03%2Fcreate-dom%2F</url>
    <content type="text"><![CDATA[控制DOM的几种js方法译DOM, 亦可称之为文档对象模型，代表整个HTML文档，可以通过其来访问页面中的所有元素，每个载入浏览器的HTML文档都会成为document的对象。它使脚本访问HTML页面元素成为可能。 document.querySelector/document.querySelectorAll document.querySelector返回的是匹配的第一个元素document.querySelectorAll返回的是匹配的所有元素 1234//return an Elementconst ul_first = document.querySelector(&apos;ul&apos;);//return an array-like Elements const ul_list = document.querySelectorAll(&apos;ul&apos;); document.creatElement 根据tag name创建一个元素。具体说明，请移步到这里 Node.appendChild 追加节点在当前节点中子节点的末尾。 1234567let list = document.createElement(&apos;ul&apos;); // creates a new list[&apos;Paris&apos;, &apos;London&apos;, &apos;New York&apos;].forEach(city =&gt; &#123; let listItem = document.createElement(&apos;li&apos;); listItem.innerText = city; list.appendChild(listItem);&#125;);document.body.appendChild(list); Node.insertBefore 插入新节点在当前子节点的前面 12345let list = document.querySelector(&apos;ul&apos;);let firstCity = list.querySelector(&apos;ul &gt; li&apos;); // here we could use list.firstChild, but the purpose of this article is to show DOM API methodslet newCity = document.createElement(&apos;li&apos;);newCity.textContent = &apos;San Francisco&apos;;list.insertBefore(newCity, firstCity); Node.removeChild 从一个指定的DOM树节点中移除其指定的子节点，返回一个被移除的那个节点 123let list = document.querySelector(&apos;ul&apos;);let firstItem = list.querySelector(&apos;li&apos;);let removedItem = list.removeChild(firstItem); Node.replaceChild 用一个新的节点或者存在的节点替换掉指定节点中的某一个节点,返回一个被替换掉的那个老节点 12345let list = document.querySelector(&apos;ul&apos;);let oldItem = list.querySelector(&apos;li&apos;);let newItem = document.createElement(&apos;li&apos;);newItem.innerHTML = &apos;Las Vegas&apos;;let replacedItem = list.replaceChild(newItem, oldItem); Node.cloneNode 创建一个指定节点的副本，他有一个boolean的参数，是一个可选项，true代表克隆本身和其所有子节点，false代表只克隆自己，不包括子节点。建议是按需求指定这个boolean值。具体参见MDN 12let list = document.querySelector(&apos;ul&apos;);let clone = list.cloneNode(); Element.getAttribute/Element.setAttribute 给指定元素节点设置属性和获取属性 1234let list = document.querySelector(&apos;ul&apos;);list.setAttribute(&apos;id&apos;, &apos;my-list&apos;);let id = list.getAttribute(&apos;id&apos;);console.log(id); // outputs my-list Element.hasAttribute/Element.removeAttribute 检查当前元素是否有这个属性和移除这个属性 12345let list = document.querySelector(&apos;ul&apos;);if (list.hasAttribute(&apos;id&apos;)) &#123; console.log(&apos;list has an id&apos;); list.removeAttribute(&apos;id&apos;);&#125;; Element.insertAdjacentHTML 插入指定的HTML片段到指定的位置，输入一个位置信息和html字符串。这里需要注意的是，如果是客户端输入是需要转义的。如果只是插入文本节点最好是用node.textContent,因为这里需要HTML解释器的转换，具体参考MDN 12345678910&lt;!-- beforebegin --&gt;&lt;div&gt; &lt;!-- afterbegin --&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;!-- beforeend --&gt;&lt;/div&gt;&lt;!-- afterend --&gt;var list = document.querySelector(&apos;ul&apos;);list.insertAdjacentHTML(&apos;afterbegin&apos;, &apos;&lt;li id=&quot;first-item&quot;&gt;First&lt;/li&gt;&apos;);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2019%2F06%2F03%2Fjava-basic-0603%2F</url>
    <content type="text"><![CDATA[java异常相关的理解 如何理解异常和错误？ 首先从java类的结构上看，异常属于Exception的分支，而错误属于Error的分支。Exception和Error都继承自Throwable这个类。从异常的类型角度分析，我们可以认为Exception是checked exception，而Error是unchecked exception。虽然这么说并不严谨，因为运行时异常作为异常的一部分其实也是unchecked exception。参考checked-and-unchecked-exceptions-in-java 如何理解NoClassDefFoundError和ClassNotFoundException? 从异常的类型看，前者是unchecked exception，因此不需要try/catch或者throws。后者是checked exception是需要try/catch或者throws，否则编译不通过。从异常的导致的原因分析，两者都是由于JVM在classpath中无法定位指定的class引起的。 如果你在J2EE开发中遇到NoClassDefFoundError，那么最有可能的原因就是存在多个类加载器和多个目标类，即我们常说的Jar包冲突——关于Jar包冲突，一般可以使用下面两种方法解决：使用Maven Helper 这个插件，可以排除掉大部分jar包冲突；根据命令mvn dependency:tree -Dverbose -Dincludes=:logback-classic 调用Class.forName()、ClassLoader.findSystemClass()和ClassLoader.loadClass()等方法时可能会引起 java.lang.ClassNotFoundException NoClassDefFoundError是链接错误，发生在链接阶段，当解析引用的时候找不到对应的类，就会抛出java.lang.NoClassDefFoundError；ClassNotFoundException是异常，发生在运行阶段。参考文章java-classnotfoundexception-and-noclassdeffounderror 对于反应式编程(Reactive Stream),因为本身是异步的基于事件机制的而且代码堆栈不再是同步调用，如何处理异常？]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2019%2F06%2F02%2Finterview-pinduoduo%2F</url>
    <content type="text"><![CDATA[拼多多面试题 介绍自己 介绍JET 介绍LA 在项目中做了什么，多少页面，做UI的有多少人 LA项目中的 viewmodel，uimodel，model是怎么划分的 Angular JS 双向绑定机制 怎么优化Performance 如果有极大量的数据和请求，浏览器会hang住很久，怎么优化。所有数据都是必须的 setTimeout setInterval 概念 一小时倒计时器，用setInterval 实现，但是用户反馈不准确，有时差，为什么？怎么改进？ CSS 如何实现水平居中和垂直居中 CSS 选择器优先级 jQuery on 实现原理 based on 上一条，如果off是on的返回，怎么写 MVC的含义 CSS position 有哪些取值，作用是什么 CSS 伪类有哪些 5个并发请求，怎么确保在他们都执行完之后，再做处理：Promise。面试官的意思还有别的答案 怎么实现$.when 跨域请求 Git 基础指令 怎么一键切换网页显示模式：白天、夜晚 VMWARE的面试题 介绍自己和项目 css: position 有哪些值及具体用法 怎么实现 css: z-index 具体用法（什么时候生效） 所有div都是绝对定位的，浏览器会怎么显示？ css选择器优先级 css伪类例举 :first-child :first-line 的区别 怎么实现垂直居中 怎么隐藏一个html元素 Display:none / visibility: hidden / html5 hidden 差别？ SASS / LESS，主要特点 事件流 HTTP请求种类 PUT vs POST PATCH Promise 与普通的异步请求有什么不同 ES6 语法 const obj = {a: 1}; obj.a = 2; // 问a的值被改了么？ VUE: 父子component之间怎么传值？ 为什么要用emit，而不允许子component直接修改props里的值 var a = 1; function test(b) { b = 2; }; test(a); // 求a var a = {key: 1}; function test(b) { b.key = 2; }; test(a); // 求a.key var a = {key: 1}; function test(b) { b = {key: 2}; }; test(a); // 求a.key 如何实现一个function add：使add(1)(2) 返回3 有一个包含重复数字的array，如何去重 斐波那契数列（1,2,3,5,8…）现实一个方法，输入n，得到数列里的第n个值 技术栈：Angular7 阿里口碑的面试题 面试官纠结于如何发布以及快速响应user发现的bug特别强调自主研究能力，自学，自己做项目 原型链响应式布局（面试官建议：PC Mobile 完全分开写）webPack事件冒泡和事件捕获事件的浏览器兼容性 反转StringString.pritotype.replace 第二个参数能否是函数？具体用法String 的 trim 不兼容的解决方案用Array模拟栈：Array.prototype.push &amp; Array.prototype.pop正则：贪婪、非贪婪正则里的特殊字符及用法 CSS水平居中垂直居中CSS 盒模型Flex具体语法Promise5个并发请求，如何做到所有请求都完成之后，再做处理？（注：若一个请求失败了，其他请求还要继续）ES6 asyncHTTP请求的种类，Get 和 POST 的区别HTTP请求返回301/302的指？重定向安全漏洞及如何预防 SAP面试题 Javascript deepcopy0.1+0.2精度问题原型链ajax底层实现Student.prototype === Student.protohtml5 新特性jQuery底层实现浏览器存储有哪些，及区别跨域knockoutjs 双向绑定原理Vue 双向绑定原理设计模式各种后端 Database 英文面：阅读理解]]></content>
  </entry>
  <entry>
    <title><![CDATA[用Hexo+Next主题搭建自己的博客网站]]></title>
    <url>%2F2019%2F06%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Ryhn’s Home, this blog site is built by Hexo! Si on veut, on peu 搭建网站所需的Hexo 参考的步骤可以在这片文章中找到.Hexo的官网 搭建网站所需的主题资源 Next的官网Hexo官网上也有一些其他朋有分享的 具体学习Markdown的网站 Markdown语法]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
