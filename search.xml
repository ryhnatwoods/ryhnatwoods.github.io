<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[跟着官方文档自学react_event]]></title>
    <url>%2F2019%2F06%2F05%2Freact-event%2F</url>
    <content type="text"><![CDATA[事件处理 react元素的事件处理和dom元素处理事件有一点语法不同 react绑定属性的命名采用驼峰式写法 如果是JSX的语法，你需要传入的是函数而不是字符串 在react中必须显示使用preventDefault函数去阻止默认的行为 为一个元素初始渲染时提供一个监听器 需要谨慎对待回调函数的this指向。通常情况下，如果你没有在方法后面添加 () ，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。如果你没有使用属性初始化器语法，你可以在回调函数中使用箭头函数。 向事件处理函数传递参数 分别通过 arrow functions 和 Function.prototype.bind 来为事件处理函数传递参数通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react_state_lifecycle]]></title>
    <url>%2F2019%2F06%2F05%2Freact-state-lifecycle%2F</url>
    <content type="text"><![CDATA[将函数转化成类 为什么要把函数转化成类？为了让组件拥有局部更新能力类中状态的特点？状态是私有的，完全受控于当前的组件，定义为类的组件有些特性，局部状态就是如此。 有一个改写clock组件的例子 这个例子很详细，直接上(链接)[https://www.reactjscn.com/docs/state-and-lifecycle.html] 正确使用状态 这个知识点很关键的。 要用setState方法更新state的状态，构造函数是唯一能够初始化state的地方 当状态更新可能是异步的时候，需要接收的是一个函数而不是对象。函数可以异步调用的。 状态更新合并，它可以分离的更新相应的状态里面的部分。这里的合并是浅合并，也就是说this.setState({comments})完整保留了this.state.posts，但完全替换了this.state.comments。 123456789101112131415161718192021constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;; &#125;componentDidMount() &#123; fetchPosts().then(response =&gt; &#123; this.setState(&#123; posts: response.posts &#125;); &#125;); fetchComments().then(response =&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;); &#125; 数据自顶向下流动 父组件和子组件都不能知道某个组件是状态还是无状态，并且它也不应该关心某个组件被定义为一个类还是一个函数。状态可以作为属性传递给子组件这通常称之为自顶向下或是单向数据流，任何状态始终有某一个特定组件持有，从该状态导出的任何数据或是UI都只影响树中下方的组件。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react-component-props]]></title>
    <url>%2F2019%2F06%2F05%2Freact-component-props%2F</url>
    <content type="text"><![CDATA[组件&amp;props 组件可以将UI切割成独立可复用的部件。组件即函数，它接收任意的输入值，并返回需要展示的react元素 123456789function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;ReactDOM.render( element, document.getElementById(&apos;root&apos;)); 组件名必须大写，个人认为组件其实就是对象，对象名称一般都以大写开头，所以这里是要大写开头哦。 组合组件 就是多个子组件拼凑自由组合在一起。 组件返回值只有一个根元素 提取组件 对于大型应用，多场景的情况，越小的组件也代表越大的灵活性，这允许我们像乐高玩具那样拼搭成我们喜欢的样子。而且这些小的组件还可以反复的利用。 Props的只读性 所有的react都必须像纯函数那样使用它们的props, 也就是你无论输入多少次一模一样的参数，它返回的结果应该都是一样的。是不是感觉有点幂等性的意思]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react-元素渲染]]></title>
    <url>%2F2019%2F06%2F05%2Freact-render-element%2F</url>
    <content type="text"><![CDATA[元素渲染 在react中，元素被当作react应用的最小单元，小到它可以是一个静态的div对象，大到它可以由许许多多小的组件汇聚而成。一般而言，如果一开始就是使用react开发的页面，那只会有一个react的容器去包裹。但是如果你是在其他项目中部分的引入react的组件，那么就可能会有多个容器存在。从更新元素渲染的角度，react元素在没有设置状态的情况下是不可变的，他就好像是过去某一个时间节点一样，你没法回到过去，不是? 但是确实react留下了把开启时间之门的钥匙，只不过是另一种方式的获取。 123456789101112//在这例子中，定时器每隔1s都会重新渲染整个react元素并添加到浏览器的dom树中。是不是感觉很累，就好像每次写错一个单词，老师都得让你罚抄整篇课文，好不爽。function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render(element, document.getElementById(&apos;root&apos;));&#125;setInterval(tick, 1000); react dom,一个可以开启时间钥匙之门的神，它会帮我们只更新那些需要更新的内容，为我们节约了成本和时间]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react-jsx]]></title>
    <url>%2F2019%2F06%2F05%2Freact-jsx%2F</url>
    <content type="text"><![CDATA[JSX简介 首先强调一下JSX不是HTML，它是一种javascript的语法扩展，这种语法的好处是可以和js无缝对接，你可以赋值给变量，你也可以直接在里面通过{}包裹去执行js表达式。不过文中特别提到为了增加代码的可读性，最好是在JSX代码外面包裹一层()。JSX支持标签的嵌套，允许表达式值的属性，属性通过小驼峰命名来定义JSX能有效防止xss攻击，因为在渲染前，它会将所有内容转换成字符串。JSX代表Object，BABEL转译器会把JSX转换成一个名为React.createElement()的方法调用，最终会返回一个react对象 1234567const element = &#123; type: &apos;h1&apos;, props: &#123; className: &apos;greeting&apos;, children: &apos;Hello, world&apos; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react-Hello World]]></title>
    <url>%2F2019%2F06%2F05%2Freact-hello-world%2F</url>
    <content type="text"><![CDATA[学习下用react来写hello world 首先需要引入react库，可以是通过script标签，也可以通过其他方式。效果可以在(jsFiddle)[https://jsfiddle.net/ryhnatwoods/d1584pe0/1/]上面看。 12ReactDOM.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;app&apos;))]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着官方文档自学react]]></title>
    <url>%2F2019%2F06%2F05%2Fzixue-react-01%2F</url>
    <content type="text"><![CDATA[跟着react官方文档自学_01On nous apprend à vivre quand la vie est passée. - Michel De Montaigne 当舒适的生活远离我们而去的时候，我们真的需要重新审视下自己，学习去适应新的生活。 点击进入react中文网首页React支持IE9和IE9+，和其他版本的浏览器。只不过需要polyfills 三个关键字很亮眼。 声明式：按照我的理解是我看到这个标签就知道这个标签作用在页面上的结果，很直观和简洁。不是很明白来自官网的解释“可以让你的代码更加可靠，且方便调试。” 组件化：创建好用有各自状态的组件，页面由一个一个组建搭配而成，感觉和乐高有点类似，很喜欢这种风格。 一次学习，随处编写：无论你现在正在用什么技术栈，你都可以随时引入react开发新特性。这个解释说实在我现在还有点懵 首页分享了分享了4个实例，感觉还不错。 组件：react组件使用render()函数构造组建显示的内容，输入的数据通过this.props传入render函数。 12345678910111213141516//这里首先构造一个HelloMessage的component对象，他接收name的属性对应的数据去返回一个react元素class HelloMessage extends React.Component &#123; render() &#123; return ( &lt;div&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125;&#125;//ReactDOM作为一个最外层的接口，将helloMessage元素渲染好添加到指定dom的容器中，并返回这个组件的引用。//其实它还有个可选的参数callback，可以在渲染更新后执行，具体可以看[render](https://www.reactjscn.com/docs/react-dom.html#render)ReactDOM.render( &lt;HelloMessage name=&quot;Taylor&quot; /&gt;, mountNode); 有状态的组建 除了使用外部传入的数据以外，组件还可以拥有其内部使用的状态数据，这个是通过this.state访问状态数据的，当组件状态发生改变时，会调用render方法重新渲染。 123456789101112131415161718192021222324252627282930313233343536//这个看名字是个计时器组件，在构造它时有个初始化的状态对象，0秒。它有一个读秒的方法，这个方法每调用一次会改变组件当前的状态，也就是+1秒。//这里你会发现组件中出现了两个生命周期的钩子函数，具体生命周期，可以看下[掘金这篇](https://juejin.im/post/5a062fb551882535cd4a4ce3).我先了解这个例子里的两个。//componentDidMount：组件已经渲染到页面后触发，此时页面中有了真正的DOM元素，可以进行DOM相关的操作//componentWillUnmount：组件销毁时被处罚，这里我们可以做一些清理的工作class Timer extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; seconds: 0 &#125;; &#125; tick() &#123; this.setState(prevState =&gt; (&#123; seconds: prevState.seconds + 1 &#125;)); &#125; componentDidMount() &#123; //这里设置了一个定时器，每隔1是自动调用tick函数更新组件状态 this.interval = setInterval(() =&gt; this.tick(), 1000); &#125; componentWillUnmount() &#123; //组件销毁时，清理掉定时器 clearInterval(this.interval); &#125; render() &#123; return ( &lt;div&gt; Seconds: &#123;this.state.seconds&#125; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Timer /&gt;, mountNode); 简单的TODO应用 这里简单的混合使用了props和state去创建了一个todo的应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//这里还是构造了一个todo的react组件，在构造过程中我们发现，继承了父类构造函数，初始化组件状态，此组件有两个可变状态，待办事项列表也就是那个items，另一个是用户输入的文本内容，也就是text。这里还初始化了两个针对这个组件的用户行为，一个是绑定在onchange事件上的handleChange回调，另外一个是绑定在onSubmit时间上的handleSubmit回调。class TodoApp extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; items: [], text: &apos;&apos; &#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; render() &#123; return ( &lt;div&gt; &lt;h3&gt;TODO&lt;/h3&gt; &lt;TodoList items=&#123;this.state.items&#125; /&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;button&gt; Add #&#123;this.state.items.length + 1&#125; &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); &#125; handleChange(e) &#123; this.setState(&#123; text: e.target.value &#125;); &#125; handleSubmit(e) &#123; e.preventDefault(); if (!this.state.text.length) &#123; return; &#125; const newItem = &#123; text: this.state.text, id: Date.now() &#125;; this.setState(prevState =&gt; (&#123; items: prevState.items.concat(newItem), text: &apos;&apos; &#125;)); &#125;&#125;//创建了一个显示所有待办事项的列表组件class TodoList extends React.Component &#123; render() &#123; return ( &lt;ul&gt; &#123;this.props.items.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; ); &#125;&#125;ReactDOM.render(&lt;TodoApp /&gt;, mountNode); 在组件中使用第三方的库 这个是利用第三方的库(Remarkable)实现一个markdown的编辑器 123456789101112131415161718192021222324252627282930313233343536class MarkdownEditor extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123; value: &apos;Type some *markdown* here!&apos; &#125;; &#125; handleChange(e) &#123; this.setState(&#123; value: e.target.value &#125;); &#125; getRawMarkup() &#123; const md = new Remarkable(); return &#123; __html: md.render(this.state.value) &#125;; &#125; render() &#123; return ( &lt;div className=&quot;MarkdownEditor&quot;&gt; &lt;h3&gt;Input&lt;/h3&gt; &lt;textarea onChange=&#123;this.handleChange&#125; defaultValue=&#123;this.state.value&#125; /&gt; &lt;h3&gt;Output&lt;/h3&gt; &lt;div className=&quot;content&quot; //这个属性是react dom自有的，用来替换innerHTML,详情请看[官网文档](https://www.reactjscn.com/docs/dom-elements.html) dangerouslySetInnerHTML=&#123;this.getRawMarkup()&#125; /&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;MarkdownEditor /&gt;, mountNode); 总结 中文react官网的第一页看完了，让我们继续深入探索react吧]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter学习]]></title>
    <url>%2F2019%2F06%2F04%2Fflutter-learn-01%2F</url>
    <content type="text"><![CDATA[跟着技术胖学flutter 小技巧：在vscode上通过flutter run开启flutter应用。press r means hot reloadTo toggle the widget inspector (WidgetsApp.showWidgetInspectorOverride), press “i”.To toggle the display of construction lines (debugPaintSizeEnabled), press “p”.To simulate different operating systems, (defaultTargetPlatform), press “o”.To toggle the elevation checker, press “z”.To display the performance overlay (WidgetsApp.showPerformanceOverlay), press “P”.To enable timeline events for all widget build methods, (debugProfileWidgetBuilds), press “a”To save a screenshot to flutter.png, press “s”.To repeat this help message, press “h”. To detach, press “d”; to quit, press “q”. 学习地址： https://juejin.im/post/5c452bac6fb9a049af6d919a https://jspang.com/posts/2017/01/11/all-video-list.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式和发布订阅模式]]></title>
    <url>%2F2019%2F06%2F04%2Fobserver-pub-sub%2F</url>
    <content type="text"><![CDATA[记录下自己对观察者模式和发布订阅模式的理解，以及自己的一点思考。 首先两者都采用的是监听机制，即某件关注的事务发生变化时，就会通知对此感兴趣的一方去做相应的处理。 观察者模式在我看来更关注观察的对象，当对象发生改变，就会相应的通知对象中维护的那些监听者或者说依赖方去按照自己的方式处理改变了的对象信息，观察对象和观察者是一种强依赖的关系。感觉有点gossip girl的感觉，一举一动都活在公众的视野下，好没有隐私啊。 发布订阅模式在我看来更注重的是发布者，但是相比与观察者模式会多一层叫事件中心，你也可以看作是一个平台，就好比一个舞台，明星想来开演唱会，喜欢这个明星的粉丝们想来听演唱会。那么这里明星就是发布者，粉丝就是订阅者。当然啦，较真的人可能会认为明星的经纪人才是真正的发布者，他们才是和举办场地做沟通的人，那个这又扯远了，这个就扯到代理模式了。那么明星发布演唱会，他会把这个信息传递给舞台方也就是举办方，举办方收到消息就会通知所有关注这个消息的粉丝群体。通过这种方式解耦发布者和订阅者。 观察者是单向的，发布订阅是双向的。其实再仔细琢磨下，这个舞台可以做演唱会，可以做联欢晚会，可以做运动会，可以做拍卖会，等等这个舞台的功能有很多，每种舞台适合不同的观众群体，发布者可以根据适合的主题发布活动，订阅者也可以根据自己喜欢的主题订阅。]]></content>
      <categories>
        <category>pattern</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控制DOM的几种js方法]]></title>
    <url>%2F2019%2F06%2F03%2Fcreate-dom%2F</url>
    <content type="text"><![CDATA[控制DOM的几种js方法译DOM, 亦可称之为文档对象模型，代表整个HTML文档，可以通过其来访问页面中的所有元素，每个载入浏览器的HTML文档都会成为document的对象。它使脚本访问HTML页面元素成为可能。 document.querySelector/document.querySelectorAll document.querySelector返回的是匹配的第一个元素document.querySelectorAll返回的是匹配的所有元素 1234//return an Elementconst ul_first = document.querySelector(&apos;ul&apos;);//return an array-like Elements const ul_list = document.querySelectorAll(&apos;ul&apos;); document.creatElement 根据tag name创建一个元素。具体说明，请移步到这里 Node.appendChild 追加节点在当前节点中子节点的末尾。 1234567let list = document.createElement(&apos;ul&apos;); // creates a new list[&apos;Paris&apos;, &apos;London&apos;, &apos;New York&apos;].forEach(city =&gt; &#123; let listItem = document.createElement(&apos;li&apos;); listItem.innerText = city; list.appendChild(listItem);&#125;);document.body.appendChild(list); Node.insertBefore 插入新节点在当前子节点的前面 12345let list = document.querySelector(&apos;ul&apos;);let firstCity = list.querySelector(&apos;ul &gt; li&apos;); // here we could use list.firstChild, but the purpose of this article is to show DOM API methodslet newCity = document.createElement(&apos;li&apos;);newCity.textContent = &apos;San Francisco&apos;;list.insertBefore(newCity, firstCity); Node.removeChild 从一个指定的DOM树节点中移除其指定的子节点，返回一个被移除的那个节点 123let list = document.querySelector(&apos;ul&apos;);let firstItem = list.querySelector(&apos;li&apos;);let removedItem = list.removeChild(firstItem); Node.replaceChild 用一个新的节点或者存在的节点替换掉指定节点中的某一个节点,返回一个被替换掉的那个老节点 12345let list = document.querySelector(&apos;ul&apos;);let oldItem = list.querySelector(&apos;li&apos;);let newItem = document.createElement(&apos;li&apos;);newItem.innerHTML = &apos;Las Vegas&apos;;let replacedItem = list.replaceChild(newItem, oldItem); Node.cloneNode 创建一个指定节点的副本，他有一个boolean的参数，是一个可选项，true代表克隆本身和其所有子节点，false代表只克隆自己，不包括子节点。建议是按需求指定这个boolean值。具体参见MDN 12let list = document.querySelector(&apos;ul&apos;);let clone = list.cloneNode(); Element.getAttribute/Element.setAttribute 给指定元素节点设置属性和获取属性 1234let list = document.querySelector(&apos;ul&apos;);list.setAttribute(&apos;id&apos;, &apos;my-list&apos;);let id = list.getAttribute(&apos;id&apos;);console.log(id); // outputs my-list Element.hasAttribute/Element.removeAttribute 检查当前元素是否有这个属性和移除这个属性 12345let list = document.querySelector(&apos;ul&apos;);if (list.hasAttribute(&apos;id&apos;)) &#123; console.log(&apos;list has an id&apos;); list.removeAttribute(&apos;id&apos;);&#125;; Element.insertAdjacentHTML 插入指定的HTML片段到指定的位置，输入一个位置信息和html字符串。这里需要注意的是，如果是客户端输入是需要转义的。如果只是插入文本节点最好是用node.textContent,因为这里需要HTML解释器的转换，具体参考MDN 12345678910&lt;!-- beforebegin --&gt;&lt;div&gt; &lt;!-- afterbegin --&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;!-- beforeend --&gt;&lt;/div&gt;&lt;!-- afterend --&gt;var list = document.querySelector(&apos;ul&apos;);list.insertAdjacentHTML(&apos;afterbegin&apos;, &apos;&lt;li id=&quot;first-item&quot;&gt;First&lt;/li&gt;&apos;);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2019%2F06%2F03%2Fjava-basic-0603%2F</url>
    <content type="text"><![CDATA[java异常相关的理解 如何理解异常和错误？ 首先从java类的结构上看，异常属于Exception的分支，而错误属于Error的分支。Exception和Error都继承自Throwable这个类。从异常的类型角度分析，我们可以认为Exception是checked exception，而Error是unchecked exception。虽然这么说并不严谨，因为运行时异常作为异常的一部分其实也是unchecked exception。参考checked-and-unchecked-exceptions-in-java 如何理解NoClassDefFoundError和ClassNotFoundException? 从异常的类型看，前者是unchecked exception，因此不需要try/catch或者throws。后者是checked exception是需要try/catch或者throws，否则编译不通过。从异常的导致的原因分析，两者都是由于JVM在classpath中无法定位指定的class引起的。 如果你在J2EE开发中遇到NoClassDefFoundError，那么最有可能的原因就是存在多个类加载器和多个目标类，即我们常说的Jar包冲突——关于Jar包冲突，一般可以使用下面两种方法解决：使用Maven Helper 这个插件，可以排除掉大部分jar包冲突；根据命令mvn dependency:tree -Dverbose -Dincludes=:logback-classic 调用Class.forName()、ClassLoader.findSystemClass()和ClassLoader.loadClass()等方法时可能会引起 java.lang.ClassNotFoundException NoClassDefFoundError是链接错误，发生在链接阶段，当解析引用的时候找不到对应的类，就会抛出java.lang.NoClassDefFoundError；ClassNotFoundException是异常，发生在运行阶段。参考文章java-classnotfoundexception-and-noclassdeffounderror 对于反应式编程(Reactive Stream),因为本身是异步的基于事件机制的而且代码堆栈不再是同步调用，如何处理异常？]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2019%2F06%2F02%2Finterview-pinduoduo%2F</url>
    <content type="text"><![CDATA[拼多多面试题 介绍自己 介绍JET 介绍LA 在项目中做了什么，多少页面，做UI的有多少人 LA项目中的 viewmodel，uimodel，model是怎么划分的 Angular JS 双向绑定机制 怎么优化Performance 如果有极大量的数据和请求，浏览器会hang住很久，怎么优化。所有数据都是必须的 setTimeout setInterval 概念 一小时倒计时器，用setInterval 实现，但是用户反馈不准确，有时差，为什么？怎么改进？ CSS 如何实现水平居中和垂直居中 CSS 选择器优先级 jQuery on 实现原理 based on 上一条，如果off是on的返回，怎么写 MVC的含义 CSS position 有哪些取值，作用是什么 CSS 伪类有哪些 5个并发请求，怎么确保在他们都执行完之后，再做处理：Promise。面试官的意思还有别的答案 怎么实现$.when 跨域请求 Git 基础指令 怎么一键切换网页显示模式：白天、夜晚 VMWARE的面试题 介绍自己和项目 css: position 有哪些值及具体用法 怎么实现 css: z-index 具体用法（什么时候生效） 所有div都是绝对定位的，浏览器会怎么显示？ css选择器优先级 css伪类例举 :first-child :first-line 的区别 怎么实现垂直居中 怎么隐藏一个html元素 Display:none / visibility: hidden / html5 hidden 差别？ SASS / LESS，主要特点 事件流 HTTP请求种类 PUT vs POST PATCH Promise 与普通的异步请求有什么不同 ES6 语法 const obj = {a: 1}; obj.a = 2; // 问a的值被改了么？ VUE: 父子component之间怎么传值？ 为什么要用emit，而不允许子component直接修改props里的值 var a = 1; function test(b) { b = 2; }; test(a); // 求a var a = {key: 1}; function test(b) { b.key = 2; }; test(a); // 求a.key var a = {key: 1}; function test(b) { b = {key: 2}; }; test(a); // 求a.key 如何实现一个function add：使add(1)(2) 返回3 有一个包含重复数字的array，如何去重 斐波那契数列（1,2,3,5,8…）现实一个方法，输入n，得到数列里的第n个值 技术栈：Angular7 阿里口碑的面试题 面试官纠结于如何发布以及快速响应user发现的bug特别强调自主研究能力，自学，自己做项目 原型链响应式布局（面试官建议：PC Mobile 完全分开写）webPack事件冒泡和事件捕获事件的浏览器兼容性 反转StringString.pritotype.replace 第二个参数能否是函数？具体用法String 的 trim 不兼容的解决方案用Array模拟栈：Array.prototype.push &amp; Array.prototype.pop正则：贪婪、非贪婪正则里的特殊字符及用法 CSS水平居中垂直居中CSS 盒模型Flex具体语法Promise5个并发请求，如何做到所有请求都完成之后，再做处理？（注：若一个请求失败了，其他请求还要继续）ES6 asyncHTTP请求的种类，Get 和 POST 的区别HTTP请求返回301/302的指？重定向安全漏洞及如何预防 SAP面试题 Javascript deepcopy0.1+0.2精度问题原型链ajax底层实现Student.prototype === Student.protohtml5 新特性jQuery底层实现浏览器存储有哪些，及区别跨域knockoutjs 双向绑定原理Vue 双向绑定原理设计模式各种后端 Database 英文面：阅读理解]]></content>
  </entry>
  <entry>
    <title><![CDATA[用Hexo+Next主题搭建自己的博客网站]]></title>
    <url>%2F2019%2F06%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Ryhn’s Home, this blog site is built by Hexo! Si on veut, on peu 搭建网站所需的Hexo 参考的步骤可以在这片文章中找到.Hexo的官网 搭建网站所需的主题资源 Next的官网Hexo官网上也有一些其他朋有分享的 具体学习Markdown的网站 Markdown语法]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
